const puppeteer = require("puppeteer");
const axios = require("axios");
const xml2js = require("xml2js");
const fs = require("fs");
const path = require("path");
const { PDFDocument, rgb, StandardFonts } = require('pdf-lib');

const URL_GITBOOK = "";

// ÈÄöÁî®ÊñáÊ™îËΩâÊèõÂô®ÔºåÁÑ°Á°¨Á∑®Á¢ºÁµêÊßã

// Function to fetch the sitemap XML and parse it
async function fetchSitemap(url) {
  try {
    const response = await axios.get(url);
    const sitemapXML = response.data;

    // Parse the XML sitemap into JSON
    const parsedSitemap = await xml2js.parseStringPromise(sitemapXML);
    
    // Ê™¢Êü•ÊòØÂê¶ÊòØ sitemapindex ËÄå‰∏çÊòØ urlset
    if (parsedSitemap.sitemapindex) {
      console.log("Found sitemap index, fetching individual sitemaps...");
      const sitemapUrls = parsedSitemap.sitemapindex.sitemap.map(sitemap => sitemap.loc[0]);
      
      // Áç≤ÂèñÊâÄÊúâÂ≠ê sitemap ÁöÑ URLs
      const allUrls = [];
      for (const sitemapUrl of sitemapUrls) {
        const subUrls = await fetchSitemap(sitemapUrl);
        if (subUrls) {
          allUrls.push(...subUrls);
        }
      }
      return allUrls;
    }
    
    if (!parsedSitemap.urlset || !parsedSitemap.urlset.url) {
      console.log("No urlset.url found in sitemap");
      return null;
    }
    
    const urls = parsedSitemap.urlset.url;

    return urls.map((url) => url.loc[0]); // Extract the 'loc' elements (URLs)
  } catch (error) {
    console.error("Error fetching or parsing sitemap:", error);
    return null;
  }
}

// Function to convert a page to PDF with selectable text and high-quality images
async function takeFullPagePdf(page, url, outputPath) {
  try {
    // Set the viewport to a reasonable width (e.g., 1280px) for full-page capture
    await page.setViewport({ width: 1280, height: 800 });

    // Set device scale factor for high DPI (2 is Retina)
    await page.emulate({
      viewport: { width: 1280, height: 800, deviceScaleFactor: 2 },
      userAgent: "",
    });

    // Go to the page and wait for it to load completely
    await page.goto(url, { waitUntil: "networkidle2" });

    // ËôïÁêÜ cookie ÂêåÊÑèÂΩàÁ™ó
    try {
      // Á≠âÂæÖ‰∏¶ÈªûÊìä Accept ÊåâÈàï
      await page.waitForSelector('button:has-text("Accept")', { timeout: 3000 });
      await page.click('button:has-text("Accept")');
      console.log('‚úÖ Cookie consent accepted');
    } catch (e) {
      // Â¶ÇÊûúÊ≤íÊúâÊâæÂà∞ÂΩàÁ™óÔºåÁπºÁ∫åÂü∑Ë°å
      try {
        // ÂòóË©¶ÂÖ∂‰ªñÂèØËÉΩÁöÑ Accept ÊåâÈàïÈÅ∏ÊìáÂô®
        const acceptButton = await page.$('button[data-testid="accept"], button[id*="accept"], button[class*="accept"], .cookie-accept, #cookie-accept');
        if (acceptButton) {
          await acceptButton.click();
          console.log('‚úÖ Cookie consent accepted (alternative selector)');
        }
      } catch (e2) {
        // ÂøΩÁï• cookie ÂΩàÁ™óÈåØË™§ÔºåÁπºÁ∫åÁîüÊàê PDF
      }
    }

    // Á≠âÂæÖÈ†ÅÈù¢Á©©ÂÆö
    await page.waitForTimeout(1000);

    // Remove elements by setting display to 'none'
    await page.evaluate(() => {
      // Remove the AppBar element
      const appBar = document.querySelector("div.appBarClassName");
      if (appBar) {
        appBar.style.display = "none";
      }

      // Remove the element with class "scroll-nojump"
      const scrollNoJump = document.querySelector(".scroll-nojump");
      if (scrollNoJump) {
        scrollNoJump.style.display = "none";
      }

      // Remove the menu element
      const menu = document.querySelector(
        "aside.relative.group.flex.flex-col.basis-full.bg-light"
      );
      if (menu) {
        menu.style.display = "none";
      }

      // Remove the search button
      const searchButton = document.querySelector(
        "div.flex.md\\:w-56.grow-0.shrink-0.justify-self-end"
      );
      if (searchButton) {
        searchButton.style.display = "none";
      }

      // Remove the next button div
      const nextButton = document.querySelector(
        "div.flex.flex-col.md\\:flex-row.mt-6.gap-2.max-w-3xl.mx-auto.page-api-block\\:ml-0"
      );
      if (nextButton) {
        nextButton.style.display = "none";
      }

      // Remove the "Last updated" info
      const lastUpdatedInfo = document.querySelector(
        "div.flex.flex-row.items-center.mt-6.max-w-3xl.mx-auto.page-api-block\\:ml-0"
      );
      if (lastUpdatedInfo) {
        lastUpdatedInfo.style.display = "none";
      }
    });

    // Convert the page to PDF with high-quality images
    await page.pdf({
      path: outputPath,
      format: "A4",
      printBackground: true,
      scale: 1,
      preferCSSPageSize: true,
    });

    console.log(`‚úÖ PDF Â∑≤‰øùÂ≠ò: ${path.basename(outputPath)}`);
  } catch (error) {
    console.error(`‚ùå ÁÑ°Ê≥ïÂâµÂª∫ PDF: ${url}`, error.message);
  }
}

// Function to group URLs based on their categories
function categorizeUrl(url) {
  const parts = url.split("/");
  
  // ËôïÁêÜÊ†πÂüüÂêç URL
  if (parts.length <= 3) {
    return "root";
  }
  
  // ËôïÁêÜÂè™Êúâ‰∏ÄÂÄãË∑ØÂæëÊÆµÁöÑ URL
  if (parts.length === 4) {
    return parts[3];
  }
  
  // ËôïÁêÜÊúâÂ§öÂÄãË∑ØÂæëÊÆµÁöÑ URLÔºå‰ΩøÁî®Á¨¨‰∫åÂÄãË∑ØÂæëÊÆµ‰ΩúÁÇ∫È°ûÂà•
  if (parts.length >= 5) {
    return parts[4];
  }
  
  return "unknown";
}

// Áç≤ÂèñÊâÄÊúâ PDF Êñá‰ª∂‰∏¶ÊåâÈ†ÅÈù¢Á∑®ËôüÊéíÂ∫è
function getAllPdfFiles(directory) {
  const files = [];
  
  function searchDirectory(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory()) {
        searchDirectory(fullPath);
      } else if (entry.isFile() && entry.name.endsWith('.pdf')) {
        const match = entry.name.match(/page_(\d+)\.pdf/);
        if (match) {
          const pageNumber = parseInt(match[1]);
          const category = path.basename(path.dirname(fullPath));
          files.push({
            path: fullPath,
            pageNumber: pageNumber,
            fileName: entry.name,
            category: category
          });
        }
      }
    }
  }
  
  searchDirectory(directory);
  files.sort((a, b) => a.pageNumber - b.pageNumber);
  return files;
}

// ÂâµÂª∫ÁõÆÈåÑÈ†Å
async function createTableOfContents(mergedPdf, sections) {
  const font = await mergedPdf.embedFont(StandardFonts.HelveticaBold);
  const regularFont = await mergedPdf.embedFont(StandardFonts.Helvetica);
  
  const page = mergedPdf.addPage([595.28, 841.89]); // A4 size
  const { width, height } = page.getSize();
  
  let yPosition = height - 100;
  
  // Ê®ôÈ°å
  page.drawText('Usual Money Complete Documentation', {
    x: 50,
    y: yPosition,
    size: 24,
    font: font,
    color: rgb(0, 0, 0)
  });
  
  yPosition -= 30;
  page.drawText('Table of Contents', {
    x: 50,
    y: yPosition,
    size: 18,
    font: font,
    color: rgb(0, 0, 0)
  });
  
  yPosition -= 40;
  
  // Ê∑ªÂä†Á´†ÁØÄ
  for (const [chapterTitle, pageNum] of sections) {
    if (yPosition < 50) {
      const newPage = mergedPdf.addPage([595.28, 841.89]);
      yPosition = height - 100;
    }
    
    page.drawText(chapterTitle, {
      x: 50,
      y: yPosition,
      size: 12,
      font: regularFont,
      color: rgb(0, 0, 0)
    });
    
    page.drawText(`Page ${pageNum}`, {
      x: width - 100,
      y: yPosition,
      size: 12,
      font: regularFont,
      color: rgb(0, 0, 0)
    });
    
    yPosition -= 25;
  }
  
  return mergedPdf;
}

// ÂâµÂª∫Á´†ÁØÄÂàÜÈöîÈ†Å
async function createSectionDivider(mergedPdf, sectionTitle) {
  const font = await mergedPdf.embedFont(StandardFonts.HelveticaBold);
  const page = mergedPdf.addPage([595.28, 841.89]);
  const { width, height } = page.getSize();
  
  // ËÉåÊôØËâ≤
  page.drawRectangle({
    x: 0,
    y: 0,
    width: width,
    height: height,
    color: rgb(0.95, 0.95, 0.95)
  });
  
  // Ê®ôÈ°å
  page.drawText(sectionTitle, {
    x: 50,
    y: height / 2,
    size: 32,
    font: font,
    color: rgb(0, 0, 0)
  });
  
  return mergedPdf;
}

// Âêà‰Ωµ PDF Êñá‰ª∂
async function mergePdfs(tempDir) {
  console.log('\nüìñ ÈñãÂßãÂêà‰Ωµ PDF Êñá‰ª∂...');
  
  const pdfFiles = getAllPdfFiles(tempDir);
  
  if (pdfFiles.length === 0) {
    throw new Error('Ê≤íÊúâÊâæÂà∞ PDF Êñá‰ª∂');
  }
  
  console.log(`üìÑ ÊâæÂà∞ ${pdfFiles.length} ÂÄã PDF Êñá‰ª∂`);
  
  // ÂâµÂª∫Êñ∞ÁöÑ PDF ÊñáÊ™î
  const mergedPdf = await PDFDocument.create();
  
  // Ë®≠ÁΩÆÊñáÊ™îÂÖÉÊï∏Êìö
  mergedPdf.setTitle('Usual Money Complete Documentation');
  mergedPdf.setAuthor('Usual Money');
  mergedPdf.setCreator('GitBook PDF Converter');
  mergedPdf.setProducer('pdf-lib');
  
  // ÊåâÈ°ûÂà•ÂàÜÁµÑÊñá‰ª∂
  const filesByCategory = {};
  pdfFiles.forEach(file => {
    if (!filesByCategory[file.category]) {
      filesByCategory[file.category] = [];
    }
    filesByCategory[file.category].push(file);
  });
  
  // Ê∫ñÂÇôÁõÆÈåÑ‰ø°ÊÅØ
  const tableOfContents = [];
  let currentPageNumber = 2; // ÂæûÁ¨¨2È†ÅÈñãÂßãÔºàÁ¨¨1È†ÅÊòØÁõÆÈåÑÔºâ
  
  // ÊåâÈ°ûÂà•Â≠óÊØçÈ†ÜÂ∫èËôïÁêÜÊâÄÊúâÂàÜÈ°ûÔºàÈÄöÁî®ÊñπÂºèÔºâ
  const sortedCategories = Object.keys(filesByCategory).sort();
  
  for (const category of sortedCategories) {
    if (filesByCategory[category] && filesByCategory[category].length > 0) {
      const files = filesByCategory[category];
      
      // Ëá™ÂãïÊ†ºÂºèÂåñÈ°ûÂà•ÂêçÁ®±
      const displayName = category.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      tableOfContents.push([displayName, currentPageNumber]);
      console.log(`üìù Ê∑ªÂä†ÂàÜÈ°û: ${displayName}`);
      
      // Ê∑ªÂä†Ë©≤È°ûÂà•ÁöÑÊâÄÊúâÊñá‰ª∂
      for (const file of files) {
        try {
          const pdfBuffer = fs.readFileSync(file.path);
          const pdf = await PDFDocument.load(pdfBuffer);
          const pageIndices = pdf.getPageIndices();
          const pages = await mergedPdf.copyPages(pdf, pageIndices);
          
          pages.forEach((page) => {
            mergedPdf.addPage(page);
          });
          
          currentPageNumber += pages.length;
        } catch (error) {
          console.error(`‚ùå ËôïÁêÜÊñá‰ª∂ ${file.fileName} ÊôÇÂá∫ÈåØ:`, error.message);
        }
      }
    }
  }
  
  // Âú®ÈñãÈ†≠ÊèíÂÖ•ÁõÆÈåÑÈ†Å
  console.log('üìã ÂâµÂª∫ÁõÆÈåÑÈ†Å...');
  await createTableOfContents(mergedPdf, tableOfContents);
  
  return mergedPdf;
}

// Ê∏ÖÁêÜËá®ÊôÇÊñá‰ª∂
function cleanupTempFiles(tempDir) {
  console.log('\nüßπ Ê∏ÖÁêÜËá®ÊôÇÊñá‰ª∂...');
  
  if (fs.existsSync(tempDir)) {
    fs.rmSync(tempDir, { recursive: true, force: true });
    console.log('‚úÖ Ëá®ÊôÇÊñá‰ª∂Â∑≤Ê∏ÖÁêÜ');
  }
}

// ‰∏ªË¶ÅÂ∑•‰ΩúÊµÅÁ®ã
async function completeWorkflow() {
  const tempDir = "./temp_pdfs";
  const finalDir = "./pdfs";
  
  console.log('üöÄ ÈñãÂßãÂÆåÊï¥Â∑•‰ΩúÊµÅÁ®ã...\n');
  
  try {
    // Ê≠•È©ü 1: ÂâµÂª∫Ëá®ÊôÇÁõÆÈåÑ
    console.log('üìÅ Ê∫ñÂÇôÂ∑•‰ΩúÁõÆÈåÑ...');
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
    fs.mkdirSync(tempDir);
    
    if (!fs.existsSync(finalDir)) {
      fs.mkdirSync(finalDir);
    }
    
    // Ê≠•È©ü 2: Áç≤Âèñ sitemap ‰∏¶‰∏ãËºâ PDF
    console.log('üîç Áç≤ÂèñÁ∂≤Á´ôÂú∞Âúñ...');
    const sitemapUrl = `${URL_GITBOOK}/sitemap.xml`;
    const urls = await fetchSitemap(sitemapUrl);
    
    if (!urls || urls.length === 0) {
      throw new Error('ÁÑ°Ê≥ïÁç≤ÂèñÁ∂≤Á´ôÂú∞ÂúñÊàñÁ∂≤Á´ôÂú∞ÂúñÁÇ∫Á©∫');
    }
    
    console.log(`üìÑ ÊâæÂà∞ ${urls.length} ÂÄãÈ†ÅÈù¢`);
    
    // Ê≠•È©ü 3: ‰∏ãËºâÊâÄÊúâÈ†ÅÈù¢ÁöÑ PDF
    console.log('\n‚¨áÔ∏è ÈñãÂßã‰∏ãËºâÈ†ÅÈù¢ PDF...');
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    let pageCounter = 1;
    
    for (const url of urls) {
      const category = categorizeUrl(url);
      const categoryDir = path.join(tempDir, category);
      
      if (!fs.existsSync(categoryDir)) {
        fs.mkdirSync(categoryDir, { recursive: true });
      }
      
      const pdfFileName = `page_${pageCounter}.pdf`;
      const pdfPath = path.join(categoryDir, pdfFileName);
      
      console.log(`üìÑ ‰∏ãËºâÈ†ÅÈù¢ ${pageCounter}/${urls.length}: ${url.split('/').pop() || 'home'}`);
      await takeFullPagePdf(page, url, pdfPath);
      
      pageCounter++;
    }
    
    await browser.close();
    
    // Ê≠•È©ü 4: Âêà‰Ωµ PDF
    const mergedPdf = await mergePdfs(tempDir);
    
    // Ê≠•È©ü 5: ‰øùÂ≠òÊúÄÁµÇ PDF
    console.log('\nüíæ ‰øùÂ≠òÊúÄÁµÇ PDF...');
    const finalOutputPath = path.join(finalDir, 'Usual_Money_Complete_Documentation.pdf');
    const pdfBytes = await mergedPdf.save();
    fs.writeFileSync(finalOutputPath, pdfBytes);
    
    // Ê≠•È©ü 6: Ê∏ÖÁêÜËá®ÊôÇÊñá‰ª∂
    cleanupTempFiles(tempDir);
    
    // ÂÆåÊàêÂ†±Âëä
    console.log('\nüéâ Â∑•‰ΩúÊµÅÁ®ãÂÆåÊàêÔºÅ');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`üìÑ Á∏ΩÈ†ÅÈù¢Êï∏: ${mergedPdf.getPageCount()}`);
    console.log(`üìÅ Ëº∏Âá∫Êñá‰ª∂: ${finalOutputPath}`);
    console.log(`üìä Êñá‰ª∂Â§ßÂ∞è: ${(pdfBytes.length / 1024 / 1024).toFixed(2)} MB`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
  } catch (error) {
    console.error('‚ùå Â∑•‰ΩúÊµÅÁ®ãÂ§±Êïó:', error.message);
    
    // Ê∏ÖÁêÜËá®ÊôÇÊñá‰ª∂ÔºàÂç≥‰ΩøÂá∫ÈåØ‰πüË¶ÅÊ∏ÖÁêÜÔºâ
    cleanupTempFiles(tempDir);
    
    throw error;
  }
}

// ÈÅãË°åÂÆåÊï¥Â∑•‰ΩúÊµÅÁ®ã
completeWorkflow().catch(console.error); 